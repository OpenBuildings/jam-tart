<!-- Subhead
================================================== -->
<header class="jumbotron subhead" id="overview">
  <div class="container">
    <h1>{{_i}}Jam Tart{{/i}}</h1>
    <p class="lead">{{_i}}Admin builder for jam, examples and guidelines.{{/i}}</p>
  </div>
</header>

  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span3 bs-docs-sidebar">
        <ul class="nav nav-list bs-docs-sidenav">
          <li><a href="#general"><i class="icon-chevron-right"></i> {{_i}}General{{/i}}</a></li>
          <li><a href="#guidelines"><i class="icon-chevron-right"></i> {{_i}}Guidelines{{/i}}</a></li>
          <li><a href="#index-action"><i class="icon-chevron-right"></i> {{_i}}Index Action{{/i}}</a></li>
          <li><a href="#custumizing"><i class="icon-chevron-right"></i> {{_i}}Custumizing{{/i}}</a></li>
          <li><a href="#access-control"><i class="icon-chevron-right"></i> {{_i}}Access Control{{/i}}</a></li>
        </ul>
      </div>
      <div class="span9">
        <!-- General
        ================================================== -->
        <section id="general">
          <div class="page-header">
            <h1>{{_i}}General{{/i}}</h1>
          </div>

          <h3>{{_i}}Requirements{{/i}}</h3>
          <p>{{_i}}This admin builder relies heavily on Jam ORM, its models and forms. It also uses jam-auth for the access control so you will need both of those modules installed and configured in order to use Jam Tart.{{/i}}</p>

          <p>{{_i}}Additionally you might want to have kohana minion installed too, as Jam Tart has several scripts that take advantage of that functionality.{{/i}}</p>

          <h3>{{_i}}minion tart:generate{{/i}}</h3>
          <p>{{_i}}This is a script that generates a fully functioning controller for a specific model:{{/i}}</p>
          
          <pre class="prettyprint linenums">./minion tart:generate --model=user</pre>

          <p>{{_i}}This will generate all the necessary files (controller and views). There are also several other options: {{/i}}</p>

          <ul>
            <li>{{_i}}<code>--module="..."</code> set the module if it's different from "admin" (default){{/i}}</li>
            <li>{{_i}}<code>--author="..."</code> set the author of the files{{/i}}</li>
            <li>{{_i}}<code>--controller="..."</code> If the controller name is different from the plural of the model name, you can set this explicitly with this option{{/i}}</li>
            <li>{{_i}}<code>--batch_delete</code> adds the ability to batch delete several items (adds checkboxes and bach delete action / view){{/i}}</li>
            <li>{{_i}}<code>--batch_modify</code> adds the ability to batch modify several items (adds checkboxes and bach delete action / view) By default it can change only the :name_key, however this is easily modified and extended after the file has been generated{{/i}}</li>
          </ul>

        </section>

        <!-- Guidelines
        ================================================== -->
        <section id="guidelines">
          <div class="page-header">
            <h1>{{_i}}Guidelines{{/i}}</h1>
          </div>

          <h3>{{_i}}Rule 1. Use Bootstrap{{/i}}</h3>
          <p>{{_i}}Always use bootstrap classes / html for your widgets. Generally it is better to use those instead of custom css / html widgets because that will limit the required understanding to "only bootstrap" making it easier to read in the future. In the rare cases where this is unsufficient, extend bootstrap to add the functionality you need (with all the docs and examples) so that it would be easy to service in the future.{{/i}}</p>

          <h3>{{_i}}Rule 2. Use HTML5{{/i}}</h3>
          <p>{{_i}}Preffer using HTML5 inputs and widgets before jquery UI, or other jquery plugins. Admins are a webapp not a webpage so browser support does not need to be very backwards compatible. If you use HTML5, then eventually all the browsers will support the feature you need, but in the meantime we can say "this works only in "safari/chrome/firefox"{{/i}}</p>

          <h3>{{_i}}Rule 3. Bootsrap-like Plugins{{/i}}</h3>
          <p>{{_i}}All JS plugins must be in the same template as bootstrap. i.e. they have to work without a single line of JS enabling them. Only with data attributes. It is also great if they are lazy-loaded in the last possible instance (e.g. typeahead loads on first "focus" event on the input field){{/i}}</p>

        </section>

        <!-- Index Action
        ================================================== -->
        <section id="index-action">
          <div class="page-header">
            <h1>{{_i}}Index Action{{/i}}</h1>
          </div>

          <h3>{{_i}}Filter{{/i}}</h3>
          <pre class="prettyprint linenums">
// Initializing the collection
$collection = Jam::all('location');

// Build the filter widgets and apply the current filters to the collection
$filter = Tart::filter($this-&gt;request-&gt;query())
  -&gt;entries(array(
    'q' =&gt; Tart::entry('search'),
  ))
  -&gt;apply($collection);

// Build index table based on the already filtered collection and the offset
$index = Tart::index($collection, $this->request->query('offset'))
  ->columns(array(
    'name' => Tart::column(),
    'actions' => Tart::column('actions'),
  ));

// Setup views, very simple ones, basically just call $index->render(); and $filter->render();
$this->template->set(array(
  'content' => View::factory('tart/locations/index', array('index' => $index, 'filter' => $filter)),
  'sidebar' => View::factory('tart/locations/sidebar', array('filter' => $filter)),
));
          </pre>
        </section>

      </div>{{! /span9 }}
    </div>{{! row}}

  </div>{{! /.container }}
