<!-- Subhead
================================================== -->
<header class="jumbotron subhead" id="overview">
  <div class="container">
    <h1>{{_i}}Tart Classes{{/i}}</h1>
    <p class="lead">{{_i}}Admin builder for jam, examples and guidelines.{{/i}}</p>
  </div>
</header>

  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span3 bs-docs-sidebar">
        <ul class="nav nav-list bs-docs-sidenav">
          <li><a href="#filter"><i class="icon-chevron-right"></i> {{_i}}Tart_Filter{{/i}}</a></li>
        </ul>
      </div>
      <div class="span9">
        <!-- General
        ================================================== -->
        <section id="general">
          <div class="page-header">
            <h1>{{_i}}Tart_Filter{{/i}}</h1>
          </div>

          <h3>{{_i}}Construct{{/i}}</h3>

          <pre class="prettyprint linenums">
$filter = Tart::filter($this-&gt;request-&gt;query(), array(
  'q' =&gt; Tart::entry('search'),
))
-&gt;apply($collection);
          </pre>

          <p>{{_i}}This first argument is an array of the current filters. The second argument is an array of the filter widgets. Each one can both render itself (create html widget) and apply a filter on the collection based on user submitted results (the first argument). There are several predefined filters:{{/i}}</p>

          <h5>Search</h5>
          <pre class="prettyprint linenums">Tart::entry('search')</pre>
          <p>filter by :name_tag</p>

          <h5>Date</h5>
          <pre class="prettyprint linenums">Tart::entry('date')</pre>
          <p>filter by a date</p>

          <h5>Radios</h5>
          <pre class="prettyprint linenums">Tart::entry('radios', array $choices)</pre>
          <p>a radio inputs based on $choices. Adds a default "all" radio, can disable it by <code>->all(FALSE);</code> or change the label with <code>->all('Every');</code></p>

          <h5>Select</h5>
          <pre class="prettyprint linenums">Tart::entry('select', array $choices)</pre>
          <p>a select input. Can set it to "multiple" with <code>->multiple(TRUE)</code></p>

          <h5>Toggles</h5>
          <pre class="prettyprint linenums">Tart::entry('toggles', array $choices)</pre>
          <p>a list of toggle buttons. Can make it vertical with <code>->vertical(TRUE)</code>. Adds a default "all" toggle, can disable it by <code>->all(FALSE);</code> or change the label with <code>->all('Every');</code></p>

          <h5>Taxonomy</h5>
          <pre class="prettyprint linenums">Tart::entry('taxonomy', array|string $vocabulary)</pre>
          <p>filter by :name_tag</p>

          <h5>Remoteselect</h5>
          <pre class="prettyprint linenums">Tart::entry('remoteselect', array('model' => ...))</pre>
          <p>filter by :name_tag</p>

          <h3>Methods:</h3>

          <h5>entries()</h5>
          <p>Getter / Setter - sets/gets one or more entries <code>->entries(array())</code> or <code>->entries('name', $entry)</code></p>

          <h5>form()</h5>
          <p>Getter / Setter - sets/gets the Jam_Form object used to build the html widgets. Creates a new form if there is nothing set</p>

          <h5>data()</h5>
          <p>
            Getter / Setter - sets/gets one or more items in the data set by the user <code>->data(array())</code> or <code>->data('name', $entry)</code>
          </p>

          <h5>render()</h5>
          <p>
            Render the filter's html form. Submiting the form should return the same data as set through the constructor / data()
          </p>

          <h5>render_active()</h5>
          <p></p>


        </section>

      </div>{{! /span9 }}
    </div>{{! row}}

  </div>{{! /.container }}
